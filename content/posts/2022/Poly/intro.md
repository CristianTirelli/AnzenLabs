---
title: "Getting the hang of polyhedral compilation"
date: 2022-04-16T14:36:47+02:00
draft: false
math: true
---



_The polyhedral model_ is an optimization and parallelization technique used to speed up the execution of **nested loops**. The main idea is to create a mathematical abstraction of a program and use it to exploit the target device's architecture through the design of sophisticated optimization heuristics. To use and understand this model, some definitions are needed.

### Static Control Parts (SCoP)
SCoPs are defined as _**a set of consecutive statements in loop nests with affine bounds and conditional expression**_.\
More restriction needs to be included in this definition, for example, _no function call in a SCoP_, _only affine access to memory_, etc.; otherwise, we cannot characterize the iteration domain of the loop statically. We skip some of those details, and we will only use code that respects that definition, besides this is only a post to get the hang of this technique.

- Example 1 of SCoP:

```c++ {linenos=true}
for (int i = 0; i < N; i++){
    for (int j = 0; j < M; j++){
        A[i][j] = i+j;
    }
}
```
The ```SCoP``` of this code is given by only one statement: ```S1: A[i][j] = i + j ```.


- Example 2 of SCoP:

```c++ {linenos=true}
for (int i = 0; i <N; i++)
    A[i] = 0;

for (int i = 0; i < N; i++){
    A[i] = i;
    for (int j = 0; j < M; j++){
        B[j] = A[i] - j;
    }
}
```
The ```SCoP``` of this code is given by the statements: 
- ```S1: A[i] = 0 ```
- ```S2: A[i] = i ```
- ```S3: B[j] = A[i] - j ```

### Iteration Domain

One of the first abstractions needed to describe the polyhedral model is the **iteration domain**. The iteration domain is a set generated by the _statement instances_, and a _statement instance_ is the execution of a statement exactly once. So the set of all the instances can be seen as the 'execution space' of the loop.

![xkcd](/xkcd_godel.png#center)

Let's take for example:
```c++ {linenos=true}
for (int i = 0; i < N; i++){
    A[i] = i;
}
```

The instance for ```i = 0``` of statment ```S1: A[i] = i``` is \\( S_1(0) = 0 \\), for ```i = 5``` we have \\( S_1(5) = 5 \\) and so on.\
What about nested loop? The same:
```c++ {linenos=true}
for (int i = 0; i < N; i++){
    for(int j = 0; j <N; j++){
        A[i][j] = i + j;
    }
}
```

In this case for statment ```S1: A[i][j] = i + j``` and ``` i = 5``` , ```j = 2``` we have 

$$
S_1 \left(
\begin{smallmatrix}
   i \\\
   j
\end{smallmatrix}
\right) = S_1 \left(
\begin{smallmatrix}
   5 \\\
   2
\end{smallmatrix}
\right) = 5 + 2 = 7
$$
where the vector \\(\vec{i_s} = \left( \begin{smallmatrix} i \\\ j \end{smallmatrix} \right)\\) is called _iteration vector_.\
\
Of course we cannot precompute all the instances, since we don't know how many they are and in general we also don't know the results.\
A proper definition of _iteration domain_ is needed and that is:
$$
\mathscr{D}_s\left(\vec{p}\right) =  \left\\{() \rightarrow \vec{i_s} \in \mathbb{Z}^{dim(\vec{i_s})} \middle| \left[D_s\right] 
\begin{pmatrix}
   \vec{i_s} \\\
   \vec{p} \\\
   1
\end{pmatrix}
\geq \vec{0}
\right\\}
$$
where \\(D_s \in \mathbb{Z}^{ m_D \times \left( dim(\vec{i_s}) + dim(\vec{p}) + 1 \right) }\\) is an integer matrix, \\(m_D\\) is the number of contraints and \\(\vec{p}\\) is the _vector of parameters_.

For example, the code:

```c++ {linenos=true}
for (int i = 0; i < N; i++){
    for (int j = 0; j < M; j++){
        A[i][j] = i+j;
    }
}
```
will have as domain:

$$
\mathscr{D}_s\left(N,M\right) =  \left\\{() \rightarrow {i \choose j} \in \mathbb{Z}^{2} \middle| 
\begin{bmatrix}
   1 & 0 & 0 & 0 & 0 \\\
   0 & 1 & 0 & 0 & 0 \\\
   -1 & 0 & 1 & 0 & -1 \\\
   0 & -1 & 0 & 1 & -1
\end{bmatrix} 
\begin{pmatrix}
   i \\\
   j \\\
   N \\\
   M \\\
   1
\end{pmatrix}
\geq \vec{0}
\right\\}
$$

The numbers in the matrix \\(D_s\\) rapresents the coefficients of the variables that define the iteration domain. If we compute the matrix-vector multiplication we get:
$$
\begin{pmatrix}
   i \\\
   j \\\
   -i + N  - 1\\\
   -j + M - 1 \\\
   1
\end{pmatrix}
\geq \vec{0}
\implies
\begin{pmatrix}
   i \\\
   j \\\
   N  - 1\\\
   M - 1 \\\
   1
\end{pmatrix}
\geq 
\begin{pmatrix}
   0 \\\
   0 \\\
   i \\\
   j \\\
   1
\end{pmatrix}
$$

that is the set of all 'boundiers' of our domain.\
If you are a visual learner, this picture can be helpful.

![itdom](/iterationdomain.png#center)

A more complex example is needed to show that local variables can be used and iteration domain can be unions of basic relations, e.g., when a condition in the input code splits the iteration domain into a union of disjoint polyhedra.

```c++ {linenos=true}
for (int i = 0; i < 2 * N; i += 2){
    for(int j = i; j < M; j++){
        if( i == j || i == 0)
            A[i][j] = i + j;
        else
            A[i][j] = -1;
    }
}
```

$$
\mathscr{D}_{s_1}\left(N,M\right) = \left\\{() \rightarrow {i \choose j} \in \mathbb{Z}^{2} \middle| 
\begin{bmatrix}
   1 & 0 & 0 & 0 & 0 \\\
   0 & 1 & 0 & 0 & 0 \\\
   -1 & 0 & 1 & 0 & -1 \\\
   0 & -1 & 0 & 1 & -1
\end{bmatrix} 
\begin{pmatrix}
   i \\\
   j \\\
   N \\\
   M \\\
   1
\end{pmatrix}
\geq \vec{0}
\right\\}
$$


$$
\mathscr{D}_{s_2}\left(N,M\right) = \left\\{() \rightarrow {i \choose j} \in \mathbb{Z}^{2} \middle| 
\begin{bmatrix}
   1 & 0 & 0 & 0 & 0 \\\
   0 & 1 & 0 & 0 & 0 \\\
   -1 & 0 & 1 & 0 & -1 \\\
   0 & -1 & 0 & 1 & -1
\end{bmatrix} 
\begin{pmatrix}
   i \\\
   j \\\
   N \\\
   M \\\
   1
\end{pmatrix}
\geq \vec{0}
\right\\}
$$

$$
\mathscr{D}_s\left(N,M\right) = \mathscr{D}_2 \left( N,M\right) \bigcup \mathscr{D}_1 \left( N,M\right)
$$







